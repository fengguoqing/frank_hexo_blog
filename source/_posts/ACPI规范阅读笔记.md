---
title: ACPI规范阅读笔记
categories: 电源管理
tags:
  - 功耗
  - ACPI
date: 2013-01-10 22:09:58
---

### 1、 ACPI主要包含以下几个部分：
- 系统电源管理
- 设备电源管理
-  处理器电源管理
-  即插即用
-  处理系统事件
-  电池管理
-  热量管理

### 2、 ACPI规范不是仅仅针对某一项调节，而是要协调各个部分，综合管理，使其达到最佳状态。
 
### 3、 ACPI是一种工业级的接口协议，它同时规范了硬件和软件的接口，使得OS可以直接配置和电源管理所有设备以及整个系统。操作系统可以收集用户、应用、硬件等各方面信息做出综合判断以及执行。
 
### 4、 支持传统BIOS电源管理的电脑从传统模式启动然后等到ACPI OS启动之后转换到工作状态。而不支持传统模式的电脑如（RISC：ARM）直接冲G3直接到G0。
 
### 5、 ACPI的几个状态
ACPI规范定义了一台兼容ACPI的计算机系统可以有以下七个状态（所谓的全局状态）：
**G0(S0)正常工作状态**
计算机的正常工作状态-操作系统和应用程序都在运行。CPU(s)执行指令。 在这个状态下(即没有进入G1睡眠)，CPU和硬盘、DVD驱动器等等这些的设备可以一再的进入和从低能源状态回来，叫做C0-Cn和D0-D3。(例如膝上型计算机，当使用电池运行的时候通常关掉所有当前未使用的设备，一些桌面型计算机也这么做来减少噪声。)
 
**G1 睡眠**
细分为从S1到S4这四种状态。系统从这几种状态被唤醒到G0运行（唤醒等待时间）所需的时间最短的是S1，较短的是S2和S3，不太短的是S4。
  **S1**
  最耗电的睡眠模式。处理器的所有寄存器被刷新，并且CPU停止执行指令。CPU和内存的电源一直维持着，一些设备如果没有被使用那么就会被停止供电。这种模式通常指上电待机或者简单叫做POS，特别在BIOS设置界面上。一些新式的计算机不再支持S1；老式的电脑对S1支持可能要比S3好。
  **S2**
  一个比S1更深的睡眠状态，不过已经不给CPU供电了；然而，通常这种模式并不被采用。
  **S3** 
  在BIOS中叫做"挂到内存" (Suspend to RAM/STR)，在Windows XP以后的Windows版本和一些Linux发行版中叫做"待机(Standby)"， 在Windows Vista和Mac OS X则叫做"睡眠(Sleep)"，虽然ACPI规范仅仅提到术语"S3"和"睡眠(Sleep)"。在这个状态下，主存储器(RAM)仍然有电源供给，尽管它也是几乎唯一的有电源供给的原件。因为操作系统、 所有应用程序和被打开的文档等等的状态都是保存在主存储器中，用户可以把工作恢复到正好上次他们保持的状态-计算机从S3状态回来时主存储器的内容和它进 入S3状态时候的内容是相同象的。(规范中提到了S3和S2是相当类似的，只有更多的组件在S3状态下会被关掉电源。) 相比较S4来说S3有两个好处；计算机恢复的过程比重启要快，第二，如果任何正在运行的应用程序(被打开的文档等等)有私有信息在里面，这些信息是不会被 写到硬盘上的。然而，在系统不能被唤醒比如遇到了电源故障的时候，高速缓冲存储器可能会被flushed来防止数据毁坏。
  **S4**
  在Windows中叫休眠， 在Mac OS X中叫作安全睡眠，也称为挂到硬盘，虽然ACPI规范中只提到了一个术语S4（main article: Hibernate(OS feature))。在这个状态下，所有主存储器的内容被储存在非挥发性存储器，例如硬盘， 保护操作系统当前的状态，包括所有应用程序,打开的文档等.这意味着从S4恢复后，用户可以恢复到原本的工作状态，采用的方法和S3是一样的。S4和S3 之间的差异是，除了把主存储器中的内容移进移出所消耗的时间以外,在S3状态下的时候如果一旦停电了,所有主存储器上的数据就会丢失,包括所有的没有保存 的文档,而在S4状态下则没有影响.S4和其他的S状态有很大不同,事实上更类似G2Soft Off状态和G3 Mechanical Off状态,而不是S1-S3.在S4状态下的系统同样可进入G3(Mechanical Off)状态,并且保留S4时候的状态信息.所以它可以恢复到以前的运行状态在关掉电源之后.

**G2（S5）Soft Off**
G2，S5，和Soft Off都是相同的叫法。G2和G3Mechanical Off几乎是相同的，但有些部件仍然带电，使计算机仍然可以被键盘、时钟、modem（电话唤醒）、LAN（网络唤醒）还有USB设备所唤醒。在启动系统从G2恢复到G0正常工作模式的过程中，无论是G3 Mechanical Off还是G2都得运行启动程序来启动操作系统。

此外，当操作系统在不支持ACPI的情况下运行，这种状态被定义为Legacy。在这个状态下，硬件和电源不是通过ACPI来管理的，实际上已经禁用了ACPI。
（参考资料：ACPI规范3.0b版的链接在下面 External links, 查看chapter 7.3.4)

**设备电源状态(Device Power State)**
设备状态对于用户来说往往是不可见的，比如当一个设备已经没有电源供应的时候，可能整个系统还是在工作状态，光驱应该是一个很好的例子吧。设备状态是与设备相关的状态，他们的定义和以下四个因素有关：
1. 设备消耗多少能源?
2. 硬件保存多少设备的上下文信息?
3. 设备要恢复工作，其驱动程序要作什么工作?
4. 延迟是多少?

设备状态有一下几个：
  **D0** Fully-On 是（正常）工作状态，电源消耗量最多，设备是完全被相应的，并且设备保留了全部的设备状态/环境。
  **D1** 和**D2**是中间电源状态，它的定义根据设备的不同而有所不同。
  **D3** Off是设备电源关闭所以对总线来说是没有相应的。设备状态/环境全部丢失，操作系统会重新初始化设备当重新给它加电的时候。这个状态下的设备恢复到D0相比之下需要最长的时间。
 
**处理器电源状态(Processor Power State)**
  处理器电源状态（C0到C3状态，后面还有Cn）是指在G0状态下（只对G0状态有效，在其他状态下不予讨论）的处理器电能消耗和温度管理的状态。只有C0状态下CPU才会执行指令，C1到Cn状态下CPU都处于各种不同程度的睡眠状态（Sleeping States），在这睡眠状态下，CPU都有一个恢复到C0的唤醒时间（latency），它是和CPU的电能消耗有关的，通常，用电能量越小意味着得花更长的时间恢复到C0状态，也就是唤醒时间越长。当在C0状态下时，ACPI允许通过定义节流阀（throttling）过程，和通过改变多性能状态（multiple performance states，P-states）来改变处理器的性能。

各个状态的定义如下所示：
    **C0**是正常工作状态，当处理器处于这种状态下的时候，它能正常处理指令。
    **C1**（通常称为Halt）拥有最短的唤醒时间，这个延时必须短到操作系统软件使用CPU的时候不会考虑到唤醒时间方面的因素。一些处理器，比如说奔腾4（Pentium 4），支持C1E（Enhanced C1 state）这样的低电能消耗技术。这个状态是不被软件所见的。
    **C2** (通常称为Stop-Clock)，这个状态下处理器维持着所有的软件所见的状态信息，但是需要更长的时间来恢复到C0。这个状态下情况最坏的硬件唤醒时间是由ACPI固件提供，并且操作系统软件可以利用这些信息来决定是采用C1而不是C2状态，C2比C1更省电。
    **C3** (通常称为Sleep)，相比C1和C2更省电了。这个状态下情况最坏的硬件唤醒时间是由ACPI固件提供，并且操作系统软件可以利用这些信息来决定是采用C2而不是C3状态，当处于C3状态时，处理器缓存保留了![clip_image001[6]](http://static.oschina.net/uploads/img/201301/10220949_UUzr.jpg)
  所有的状态信息，但是忽略所有的侦听。操作系统软件负责保证缓存数据的一致性。
  ![clip_image003[6]](http://static.oschina.net/uploads/img/201301/10220950_eHZ6.jpg "c5-c0-c5")
  ![clip_image005[6]](http://static.oschina.net/uploads/img/201301/10220951_Ds0z.jpg "c0-c4-c0")
  下面简单的说一下，CPU 信号解锁 随后到来是 STPCLK# 之后CPU 信号被锁定。 南桥发出DPSLP# 意思为：深度睡眠，DPSLP＃是由CH9南桥发出。当信号低，处理器进入深度睡眠状态会关闭处理器的处理器核心时钟。 接着来的是STP_CPU#，但是CPU的 时钟信号还是一直保持着的。随着唤醒的来了，信号逐一解锁，CPU 开始接受信号 正常工作。C0 TO C5/C6 不同的时候会关闭VCORE,多了一些信号。
### 6、 D0和C0状态都可以分为P0-Pn，性能和耗电量逐渐递减。
![clip_image007[6]](http://static.oschina.net/uploads/img/201301/10220953_psLc.png)
![clip_image009[6]](http://static.oschina.net/uploads/img/201301/10220955_atSR.jpg)
### 7、 ACPI Table会被载入到内存中，BIOS和OS都可以去读取和修改它。
### 8、 ACPI将硬件分为两类:FIXED，GENERIC。在FIXED范围内的硬件必须满足ACPI编程和行为标准.在GENERIC范围内的硬件在实现时有一定程度的灵活性。FIXED编程模型要求在特定的地址位置定义寄存器，而GENERIC编程模型则允许寄存器被安排在更广泛的地址空间。ACPI驱动器可以直接操作FIXED寄存器空间，而ACPI依赖0EM厂商提供的“伪码”(ASL码)来操作GENERIC寄存器空间。
### 9、 每一睡眠状态都指定:谁负责保持系统上下文，谁负责唤醒序列。
### 10、 当OS既支持传统又支持ACPI时，启动首先进入传统模式然后再由操作系统转为ACPI模式。
### 11、 R00T SYSTEM DESCRIPTION PONITER结构位于系统的内存空间，由BIOS建立，这个结构中有ROOT SYSTEM DESCRIPTION TABLE的地址，RSDT表中有指向其他表的指针，这些表向操作系统提供了基本系统实现和配置信息。RSDT中的指针指向内存中的其他表。RSDT的地址由RSDP提供，而RSDP保存在Extended BIOS Data Area (EBDA), or in the BIOS read-only memory space，OSPM只有通过搜索特定魔数即"RSD PTR "字符串来确定RSDP，RSDT总是第一个表，它指向FACP(FIXED ACPI TABLE)，FACP表包括许多描述硬件FIXED ACPI特性的固定长度的入口。
![clip_image011[6]](http://static.oschina.net/uploads/img/201301/10220955_B2bv.jpg)
![clip_image013[6]](http://static.oschina.net/uploads/img/201301/10220957_X1GX.jpg)
### 12、SCI_EN决定了中断是由SMI处理还是SCI来处理。
![clip_image015[6]](http://static.oschina.net/uploads/img/201301/10220958_aFdV.jpg)
### 13、 “^”代表父路径，“\”代表根路径root，“.”路径分割符。
### 14、 `BNUM ：0x7F2EBC46`,最后一位决定电池是否存在，B1ST第三位决定。然而要刷新BNUM必须首先执行`Method (_REG, 2, NotSerialized)`或者`Method (_Q33, 0, NotSerialized)`才可以。目前亟需要弄清楚这些方法是如何调用的，什么时候调用的。



